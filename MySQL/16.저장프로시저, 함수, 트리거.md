# SQL - 저장 프로시저, 함수, 트리거

### 1. 저장 프로시저 (Stored Procedure)

저장 프로시저는 복잡한 SQL 쿼리문들을 마치 하나의 함수처럼 데이터베이스에 저장해 두었다가, 필요할 때 호출하여 실행하는 객체임.

| 기능 | 명령어 (Syntax) | 사용 예시 (Example) |
| --- | --- | --- |
| **생성** | `CREATE PROCEDURE [명](인자) BEGIN ... END;` | `CREATE PROCEDURE GetCustomerOrder(IN c_id INT) ...` |
| **호출** | `CALL [프로시저명](인자);` | `CALL GetCustomerOrder(1);` |
| **삭제** | `DROP PROCEDURE [프로시저명];` | `DROP PROCEDURE GetCustomerOrder;` |

* **포인트**: 프로시저는 비즈니스 로직을 DB 단에서 일괄 처리할 수 있어 네트워크 트래픽을 줄이고 성능을 향상시킬 수 있음.

<br>

### 2. 사용자 정의 함수 (User Defined Function)

함수는 특정 계산을 수행하고 그 **결과값을 반환**하기 위해 사용합니다. 주로 `SELECT` 절이나 `WHERE` 절에서 호출됨.

* **프로시저와 차이점**: 프로시저는 `CALL`로 실행하며 결과값이 없을 수 있지만, 함수는 반드시 `RETURN`을 통해 값을 반환해야 하며 일반 SQL 문 안에서 바로 사용됨.
* **사용 예시**:
```sql
SELECT name, GetDiscountPrice(price) FROM products; -- 가격 할인 계산 함수 호출
```

<br>

### 3. 트리거 (Trigger)

트리거는 "방아쇠"라는 뜻처럼, 특정 테이블에 `INSERT`, `UPDATE`, `DELETE` 같은 **이벤트가 발생할 때 자동으로 실행**되는 로직임.

| 구분 | 설명 | 실무 활용 예시 |
| --- | --- | --- |
| **BEFORE** | 데이터가 변경되기 전에 실행 | 데이터 유효성 검사, 값 보정 |
| **AFTER** | 데이터가 변경된 후에 실행 | 로그 기록(Audit), 통계 테이블 업데이트 |

* **포인트**: 주문이 발생했을 때 상품 재고를 자동으로 감소시키거나, 회원 탈퇴 시 로그를 남기는 작업 등에 유용하게 사용됨.

<br>

### 4. 구분 기호 (DELIMITER)

프로시저나 트리거 내부에는 여러 개의 세미콜론(`;`)이 포함됨. 이때 SQL 문이 중간에 끊기지 않고 전체가 저장될 수 있도록 일시적으로 종료 문자를 변경해주는 과정이 필요.

* 예: `DELIMITER //` (작성) `DELIMITER ;` (복구)

<br>

### 5. 시나리오별 사용 예시 (Scenario & Example)

* **저장 프로시저 (Batch Process)**: "신규 회원 가입 시 환영 쿠폰과 포인트를 한 번에 지급"
```sql
DELIMITER //
CREATE PROCEDURE RegisterWelcomeGift(IN m_id INT)
BEGIN
    -- 1. 환영 쿠폰 지급
    INSERT INTO coupons (member_id, type) VALUES (m_id, 'WELCOME_10');
    -- 2. 가입 포인트 1000점 지급
    INSERT INTO points (member_id, amount) VALUES (m_id, 1000);
END //
DELIMITER ;

-- 애플리케이션에서는 프로시저 하나만 호출하면 됨
CALL RegisterWelcomeGift(123);

```
<br>

* **사용자 정의 함수 (Formatting)**: "상품 가격에 세금을 포함하여 출력하는 함수"
```sql
-- 가격에 10% 부가세를 더해 반환함
CREATE FUNCTION GetTaxPrice(p_price DECIMAL) RETURNS DECIMAL
DETERMINISTIC
BEGIN
    RETURN p_price * 1.1;
END;

-- 조회 시 일반 컬럼처럼 편리하게 사용함
SELECT name, price, GetTaxPrice(price) AS tax_included FROM product;

```
<br>

* **트리거 (Audit/Logging)**: "상품 가격이 변경될 때마다 이전 가격과 변경 시간을 로그 테이블에 기록"
```sql
CREATE TRIGGER trg_price_history
AFTER UPDATE ON product
FOR EACH ROW
BEGIN
    -- 가격이 변경된 경우만 실행함
    IF OLD.price <> NEW.price THEN
        INSERT INTO price_logs (product_id, old_price, new_price, changed_at)
        VALUES (OLD.id, OLD.price, NEW.price, NOW());
    END IF;
END;

```
<br>

* **트리거 (Stock Management)**: "주문이 완료되면 상품 재고를 자동으로 차감"
```sql
CREATE TRIGGER trg_reduce_stock
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    UPDATE product 
    SET stock = stock - NEW.quantity 
    WHERE id = NEW.product_id;
END;

```
<br>

### 6. 실무 포인트

* **로직의 분산 주의**: 너무 많은 비즈니스 로직을 DB(프로시저/트리거)에 넣으면 애플리케이션 코드를 보면서 전체 흐름을 파악하기 어려워지고 유지보수가 힘들어질 수 있음.
* **트리거의 투명성**: 트리거는 눈에 보이지 않게 자동으로 작동하므로, 시스템 장애 발생 시 원인 파악이 늦어질 수 있음. 꼭 필요한 경우에만 신중히 사용해야함.
* **성능과 보안**: 복잡한 연산을 DB 서버에서 직접 처리하므로 애플리케이션 서버의 부하를 덜어줄 수 있고, 쿼리문 자체를 노출하지 않아 보안상 이점이 있음.