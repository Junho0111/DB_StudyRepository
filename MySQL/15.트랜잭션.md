# SQL - 트랜잭션 (Transaction)

### 1. 트랜잭션의 개념

트랜잭션은 데이터베이스의 상태를 변화시키기 위해 수행하는 **'작업의 단위'**를 말함. 여러 개의 SQL 문을 하나의 논리적 단위로 묶어서, **"모두 성공하든지 아니면 모두 실패해야 한다"**는 원칙을 가짐.

<br>

### 2. 트랜잭션의 핵심 성질 (ACID)
| 성질 | 명칭 | 설명 |
| --- | --- | --- |
| **Atomicity** | **원자성** | 트랜잭션 내의 모든 작업은 하나의 단위로 취급됨. (All or Nothing) |
| **Consistency** | **일관성** | 트랜잭션 완료 후 데이터베이스는 항상 일관된 상태를 유지해야 함. |
| **Isolation** | **격리성** | 동시에 실행되는 트랜잭션들이 서로에게 영향을 주지 않아야 함. |
| **Durability** | **지속성** | 성공적으로 완료된 트랜잭션 결과는 영구적으로 기록되어야 함. |

<br>

### 3. 트랜잭션 제어 명령어 (TCL)

트랜잭션을 수동으로 관리할 때 사용하는 명령어.

| 명령어 | 설명 | 비유 |
| --- | --- | --- |
| **START TRANSACTION** | 트랜잭션의 시작을 알림. | 작업 시작 |
| **COMMIT** | 모든 변경 사항을 확정하고 반영함. | 저장하기 |
| **ROLLBACK** | 작업 중 오류 발생 시 모든 변경을 취소하고 시작 전으로 되돌림. | 실행 취소 (Ctrl + Z) |

<br>

### 4. 자동 커밋 (Auto Commit)

* **개념**: 각각의 SQL 문이 실행될 때마다 자동으로 `COMMIT`을 호출하는 설정.
* **실무 포인트**: MySQL 등 대다수의 DB는 기본적으로 Auto Commit 모드가 켜져 있음. 트랜잭션을 수동으로 관리하려면 `START TRANSACTION`을 사용하여 명시적으로 시작하거나 설정을 변경해야함

<br>

### 5. 시나리오별 사용 예시 (Scenario & Example)

* **계좌 이체 (원자성 보장)**: "출금은 성공했는데 입금에서 오류가 발생한 상황"
```sql
START TRANSACTION; -- 트랜잭션 시작

-- 1. A의 잔액을 10,000원 감소시킴
UPDATE accounts SET balance = balance - 10000 WHERE user_id = 'A';

-- 2. B의 잔액을 10,000원 증가시킴 (시스템 오류 발생 가정)
-- 에러 발생 시 아래 ROLLBACK을 수행하여 A의 돈도 깎이지 않게 함
ROLLBACK; 

-- 만약 1, 2번 모두 정상 처리되었다면 최종 반영
-- COMMIT;

```
<br>

* **주문 처리 시스템**: "재고 감소와 주문 내역 생성을 하나의 단위로 묶음"
```sql
START TRANSACTION;

-- 1. 상품 재고 차감
UPDATE products SET stock = stock - 1 WHERE id = 101;

-- 2. 주문 내역 삽입
INSERT INTO orders (product_id, member_id, quantity) VALUES (101, 1, 1);

-- 재고가 부족하거나 에러 발생 시 취소, 문제 없으면 확정
COMMIT;

```
<br>

* **SAVEPOINT 활용**: "작업이 길어질 때 특정 지점까지만 되돌리기"
```sql
START TRANSACTION;

INSERT INTO logs VALUES ('작업1 시작');
SAVEPOINT point1; -- 세이브포인트 생성

INSERT INTO logs VALUES ('작업2 시작');
-- 작업2 도중 문제가 생겨 point1 지점(작업1 완료 상태)으로만 되돌림
ROLLBACK TO point1;

COMMIT; -- 작업1 내용만 최종 반영됨

```
<br>

### 6. 실무 포인트

* **이체 예시 (The Classic Example)**: 가장 강조되는 사례. 'A계좌에서 돈을 빼고 B계좌에 넣는 작업' 중, 돈을 뺐는데 시스템 오류로 입금이 안 된다면? 이때 트랜잭션의 **원자성**이 없다면 돈이 공중으로 사라지게됨.
* **격리 수준 (Isolation Level)**: 동시에 여러 사용자가 같은 데이터를 수정할 때 발생하는 문제를 방지하기 위해 격리 수준을 설정해야함. (예: Read Committed, Repeatable Read 등)
* **서비스 로직과의 관계**: 실제 개발 시에는 DB의 트랜잭션 기능을 활용하여 비즈니스 로직 전체가 안전하게 처리되도록 설계하는 것이 개발자의 가장 중요한 역량 중 하나임.