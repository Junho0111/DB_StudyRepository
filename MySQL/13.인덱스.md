# SQL - 인덱스 (Index) 기초 및 활용

### 1. 인덱스의 개념

인덱스는 책의 맨 뒤에 있는 **'색인'**과 같음. 방대한 데이터 중에서 원하는 정보를 빠르게 찾기 위해 특정 컬럼의 값과 그 값이 위치한 주소를 따로 저장해두는 공간임.

<br>

### 2. 인덱스의 장단점

| 구분 | 장점 (Pros) | 단점 (Cons) |
| --- | --- | --- |
| **조회 (SELECT)** | 검색 속도가 획기적으로 빨라짐. (Full Table Scan 방지) | 인덱스가 설정된 컬럼을 기준으로 조회 시 성능 최적화. |
| **변경 (CUD)** | 해당 사항 없음. | `INSERT`, `UPDATE`, `DELETE` 시 인덱스도 함께 갱신해야 하므로 성능이 저하됨. |
| **저장 공간** | 해당 사항 없음. | 인덱스를 위한 별도의 저장 공간(약 10~15%)이 필요함. |

<br>

### 3. 인덱스 생성 및 관리 (문법)

| 기능 | 명령어 (Syntax) | 사용 예시 (Example) |
| --- | --- | --- |
| **인덱스 생성** | `CREATE INDEX [명] ON [테이블]([컬럼]);` | `CREATE INDEX idx_product_name ON products(name);` |
| **인덱스 확인** | `SHOW INDEX FROM [테이블명];` | `SHOW INDEX FROM products;` |
| **인덱스 삭제** | `DROP INDEX [명] ON [테이블명];` | `DROP INDEX idx_product_name ON products;` |

* **참고**: `PRIMARY KEY`를 생성하면 DB가 자동으로 '클러스터형 인덱스'를 생성.

<br>

### 4. 인덱스의 작동 원리와 B-Tree

대부분의 관계형 DB는 **B-Tree(Balanced Tree)** 구조로 인덱스를 관리. 데이터를 정렬된 상태로 유지하며, 이진 탐색과 유사한 방식으로 원하는 데이터를 빠르게 찾음.

<br>

### 5. 인덱스 설계 원칙 

"어떤 컬럼에 인덱스를 걸어야 하는가?"에 대한 기준.

1. **카디널리티(Cardinality)가 높은 컬럼**: 값의 종류가 많고 중복도가 낮은 컬럼(예: 이메일, 주민번호)이 인덱스 효율이 좋음. (성별처럼 중복이 많은 컬럼은 비효율적)
2. **WHERE 절에 자주 등장하는 컬럼**: 검색 조건으로 빈번하게 사용되는 컬럼을 우선 고려.
3. **JOIN이나 ORDER BY에 사용되는 컬럼**: 테이블 간 결합이나 데이터 정렬 시 인덱스가 있으면 성능이 크게 향상.
4. **수정 빈도가 낮은 컬럼**: 데이터 변경이 잦으면 인덱스 재구성 비용이 커지므로 주의해야함.

<br>

### 6. 복합 인덱스 (Composite Index)

두 개 이상의 컬럼을 합쳐서 만드는 인덱스.

* **주의사항**: 컬럼의 **순서**가 매우 중요. (첫 번째 컬럼을 조건에서 사용하지 않으면 인덱스가 작동하지 않을 수 있음)

<br>

### 7. 실무 포인트

* **Full Table Scan을 피하라**: 인덱스가 없으면 DB는 처음부터 끝까지 모든 데이터를 뒤져야함. 데이터가 수백만 건일 경우 서비스 장애로 이어질 수 있음.
* **인덱스 남용 금지**: 인덱스가 너무 많으면 조희 성능은 좋아질지 몰라도 데이터 삽입/수정 시 배보다 배꼽이 더 커지는 상황이 발생함.
* **실행 계획(Explain) 확인**: 내가 만든 인덱스가 실제로 잘 작동하는지 확인하기 위해 쿼리 앞에 `EXPLAIN`을 붙여 실행 계획을 분석하는 습관을 들여야함.