# 데이터베이스 설계 (논리적 모델링 - 키)

### 1. 논리적 모델링이란?

개념적 모델링(ERD)을 바탕으로 상세 속성을 정의하고, 특정 DBMS의 물리적 구조에 맞게 매핑하기 전 단계임. 이 과정에서 가장 핵심이 되는 것이 바로 **'키(Key)의 설정'**임.

<br>

### 2. 키(Key)의 종류와 개념

행(Row)을 식별하기 위한 다양한 키의 개념.

| 키 종류 | 설명 | 특징 |
| --- | --- | --- |
| **슈퍼 키 (Super Key)** | 행을 유일하게 식별할 수 있는 하나 이상의 컬럼 집합 | 유일성만 만족하면 됨. |
| **후보 키 (Candidate Key)** | 슈퍼 키 중에서 더 이상 줄일 수 없는 최소한의 컬럼 집합 | **유일성 + 최소성**을 모두 만족. |
| **기본 키 (Primary Key)** | 후보 키 중에서 설계자가 최종적으로 선택한 주 식별자 | **NULL 불가, 중복 불가.** |
| **대체 키 (Alternate Key)** | 후보 키 중 기본 키로 선택되지 않은 나머지 키 | (예: 주민번호가 PK면 이메일은 대체 키) |
| **외래 키 (Foreign Key)** | 다른 테이블의 기본 키를 참조하는 컬럼 | **테이블 간의 관계**를 연결하는 열쇠. |

<br>

### 3. 기본 키(Primary Key) 선택 전략 

* **자연 키 (Natural Key)**: 비즈니스적으로 의미가 있는 값을 키로 사용 (예: 이메일, 주민번호, 전화번호).
* **대리 키 (Surrogate Key)**: 비즈니스와 무관하게 시스템에서 생성한 임의의 값 (예: MySQL의 `AUTO_INCREMENT`, Oracle의 `Sequence`).

> **권장 사항**: 실무에서는 **대리 키(인공 키)**를 기본 키로 사용하는 것을 강력히 권장. 비즈니스 환경이 변해 이메일이나 전화번호가 바뀌거나 중복되는 상황이 발생해도 시스템 구조를 안정적으로 유지할 수 있기 때문.

<br>

### 4. 외래 키(Foreign Key)와 관계의 구현

논리적 모델링에서는 개념적 모델링의 '관계(선)'가 '외래 키(컬럼)'로 변환됨.

* **1:N 관계**: '다(N)' 쪽 테이블에 '일(1)' 쪽의 PK를 외래 키로 추가함.
* 예: '회원(1)'과 '주문(N)' 관계에서 `주문` 테이블에 `회원_ID`를 FK로 넣음.


* **참조 무결성**: 외래 키는 참조하는 테이블에 존재하는 값만 가질 수 있도록 제한하여 데이터의 일관성을 보장함.

<br>

### 5. 시나리오별 사용 예시 (Scenario & Example)

* **자연 키 vs 대리 키 선택**: "회원 테이블의 PK를 이메일로 했을 때의 문제점"
```sql
-- [나쁜 설계: 자연 키] 
-- 이메일(PK)은 비즈니스 로직에 의해 변경될 수 있음. 
-- 이메일 변경 시 이를 참조하는 주문, 게시글 등 모든 외래 키를 업데이트해야 함.
CREATE TABLE members (
    email VARCHAR(100) PRIMARY KEY, -- 비즈니스 의미가 담긴 키
    name VARCHAR(50)
);

-- [좋은 설계: 대리 키] 
-- 시스템이 생성한 id를 사용하면 이메일이 바뀌어도 관계(FK)가 깨지지 않음.
CREATE TABLE members (
    member_id BIGINT AUTO_INCREMENT PRIMARY KEY, -- 시스템용 인공 키
    email VARCHAR(100) UNIQUE, -- 대체 키로 활용
    name VARCHAR(50)
);

```
<br>

* **1:N 관계의 외래 키 구현**: "부서와 직원 테이블 연결"
```sql
-- 부서(1) : 직원(N) 관계에서 '다(N)'인 직원 테이블에 부서 ID를 추가함
CREATE TABLE departments (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50)
);

CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    name VARCHAR(50),
    dept_id INT, -- 외래 키 (Foreign Key)
    CONSTRAINT fk_dept FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
);

```
<br>

* **복합 키(Composite Key)의 대리 키 전환**: "복잡한 식별자를 단순화"
```sql
-- [기존: 복합 키] (강의실번호 + 시간) 두 컬럼을 묶어 PK로 사용 시 조인 쿼리가 복잡해짐
-- [개선: 대리 키] 별도의 reservation_id를 PK로 두고, 기존 조건은 UNIQUE 제약으로 관리
CREATE TABLE reservations (
    reservation_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    room_number INT,
    reserve_time DATETIME,
    UNIQUE (room_number, reserve_time)
);

```
<br>

* **참조 무결성 유지**: "존재하지 않는 부서에 직원을 배정할 때의 방어"
```sql
-- departments 테이블에 없는 dept_id를 넣으려 하면 DB 차원에서 에러 발생
INSERT INTO employees (emp_id, name, dept_id) VALUES (1, '김철수', 999); 
-- Result: Foreign key constraint fails

```
<br>

### 6. 요약 & 실무 포인트

* **PK는 절대 변하면 안 된다**: 기본 키 값은 한 번 정해지면 영원히 변하지 않아야함. 그래서 비즈니스 의미가 담긴 자연 키보다는 시스템이 관리하는 대리 키가 안전함.
* **복합 키(Composite Key) 지양**: 두 개 이상의 컬럼을 합쳐 PK로 만드는 것은 쿼리를 복잡하게 만들고 인덱스 효율을 떨어뜨릴 수 있으니 가급적 단일 컬럼 대리 키를 사용해야함.
* **외래 키의 인덱스**: FK 컬럼에는 보통 인덱스를 생성함. ==> 조인(Join) 성능에 직접적인 영향을 주기 때문임.