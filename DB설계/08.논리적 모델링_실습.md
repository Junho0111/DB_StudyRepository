# 데이터베이스 설계 (논리적 모델링)

### 1. 개념적 모델링에서 논리적 모델링으로의 전환

핵심은 **"추상적인 관계선을 실제 외래 키(FK) 컬럼으로 치환"**하고, **"다대다(N:M) 관계를 해소"**하는 것임 .

<br>

### 2. 다대다(N:M) 관계 해소 

**'상품(Product)'**과 **'카테고리(Category)'**의 다대다 관계를 해결하는 과정.

* **문제**: 상품 하나가 여러 카테고리에 속하고, 카테고리 하나에 여러 상품이 있음.
* **해결**: 중간에 `PRODUCT_CATEGORY`라는 **연결 테이블**을 생성.
* **구조**:
* `PRODUCT_CATEGORY` 테이블은 `PRODUCT_ID`와 `CATEGORY_ID`를 FK로 가짐.
* 이를 통해 `PRODUCT : PRODUCT_CATEGORY = 1:N`, `CATEGORY : PRODUCT_CATEGORY = 1:N` 관계로 변환됨.

<br>

### 3. 일대다(1:N) 및 식별/비식별 적용 

**'회원(Member)'**과 **'주문(Order)'** 관계를 설계.

* **회원(1) : 주문(N)**: `ORDER` 테이블에 `MEMBER_ID`를 FK로 추가.
* **비식별 관계 적용**: `ORDER` 테이블은 부모인 `MEMBER_ID`를 PK로 쓰지 않고, 별도의 `ORDER_ID`(대리 키)를 PK로 가짐. (실무 권장 방식)

<br>

### 4. 테이블 상세 설계 

| 테이블명 | PK (기본 키) | FK (외래 키) | 주요 일반 속성 |
| --- | --- | --- | --- |
| **MEMBER** | `MEMBER_ID` | - | 이름, 이메일, 주소 |
| **PRODUCT** | `PRODUCT_ID` | - | 상품명, 가격, 재고 |
| **ORDER** | `ORDER_ID` | `MEMBER_ID` | 주문일시, 주문상태 |
| **ORDER_ITEM** | `ORDER_ITEM_ID` | `ORDER_ID`, `PRODUCT_ID` | 주문가격, 수량 (주문-상품 연결) |
| **CATEGORY** | `CATEGORY_ID` | - | 카테고리명 |
| **PRODUCT_CAT** | `ID` (또는 복합키) | `PRODUCT_ID`, `CATEGORY_ID` | (상품-카테고리 연결) |

<br>

### 5. 시나리오별 사용 예시 (Scenario & Example)

* **다대다(N:M) 해소와 연결 테이블**: "상품과 카테고리의 실제 데이터 매핑"
```sql
-- 상품(아이폰)이 '전자기기'와 '애플' 카테고리에 동시 소속됨
INSERT INTO product_category (product_id, category_id) VALUES (1, 10); -- 아이폰, 전자기기
INSERT INTO product_category (product_id, category_id) VALUES (1, 11); -- 아이폰, 애플

```
<br>

* **연결 테이블의 엔티티화**: "단순 연결을 넘어선 주문 상품(ORDER_ITEM) 관리"
```sql
-- 주문(Order)과 상품(Product)을 잇는 중간 테이블에 '수량'과 '결제 단가'를 포함함
-- 단순 연결 기능에 비즈니스 데이터(수량, 가격)가 추가되어 중요한 엔티티가 됨
CREATE TABLE order_item (
    order_item_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    order_id BIGINT NOT NULL,
    product_id BIGINT NOT NULL,
    order_price INT NOT NULL, -- 주문 시점의 가격 보존
    count INT NOT NULL        -- 주문 수량
);

```
<br>

* **비식별 관계와 외래 키**: "회원과 주문의 물리적 연결"
```sql
-- 회원(1) : 주문(N) 관계에서 주문 테이블이 회원 ID를 참조함
-- 주문 테이블은 자신의 PK(order_id)를 가지며 회원 ID는 FK로만 존재함(비식별)
INSERT INTO orders (order_id, member_id, status) VALUES (501, 1, 'SHIPPING');

```
<br>

* **복합 키 대신 대리 키 사용**: "연결 테이블의 관리 편의성"
```sql
-- (PRODUCT_ID, CATEGORY_ID)를 묶어 PK로 쓰는 대신 
-- 별도의 ID(AUTO_INCREMENT)를 PK로 두어 매핑 구조를 단순화함
CREATE TABLE product_category (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    product_id BIGINT,
    category_id BIGINT
);

```
<br>

### 6. 실습 마무리 & 검토 포인트

* **연결 테이블의 이름**: 보통 두 테이블의 이름을 합쳐서 짓거나(`PRODUCT_CATEGORY`), 그 자체가 하나의 의미를 가지면 새로운 이름(`ORDER_ITEM`)을 부여함.
* **대리 키의 일관성**: 모든 테이블에 `id`라는 이름의 PK를 두고 `AUTO_INCREMENT`를 설정하면 개발 생산성이 올라감.
* **매핑 테이블의 확장성**: `ORDER_ITEM` 테이블에 '주문 가격'과 '수량' 속성을 추가한 것처럼, 단순히 연결만 하는 게 아니라 **관계에서 발생하는 데이터**를 담는 것이 실무 설계의 핵심임.
