# 통계 테이블 설계 (Statistics Table Design)

### 1. 통계 테이블의 필요성

데이터가 수백만, 수천만 건이 넘어가면 사용자 화면에서 실시간으로 `SUM`, `COUNT`, `AVG` 같은 집계 쿼리를 실행하는 것은 불가능함.

* **문제점**: 실시간 집계 시 DB CPU 점유율 상승, 서비스 응답 속도 저하, 다른 트랜잭션과의 락(Lock) 충돌 발생.
* **해결책**: 원본 데이터를 미리 집계하여 별도의 **통계 전용 테이블**에 저장해둠.

<br>

### 2. 통계 테이블 설계 방식 (집계 단위)

통계는 비즈니스 요구사항에 따라 집계 단위를 다르게 설계함.

* **시간 단위 집계**: 시간별 주문 건수, 분 단위 접속자 수.
* **일/월/년 단위 집계**: 일별 매출액, 월별 가입자 수.
* **항목별 집계**: 상품별 판매 순위, 카테고리별 매출 비중.

<br>

### 3. 통계 데이터 생성 시점 (Update Strategy)

통계 테이블에 데이터를 채우는 방식은 크게 두 가지.

| 방식 | 설명 | 장점 | 단점 |
| --- | --- | --- | --- |
| **배치 처리 (Batch)** | 특정 주기(예: 매일 새벽)마다 전날 데이터를 한꺼번에 집계 | 시스템 부하가 적고 구현이 단순함 | 실시간 통계 확인이 불가능함 |
| **실시간/준실시간** | 데이터 변경 시 트리거나 이벤트를 통해 즉시 통계 테이블 업데이트 | 항상 최신 통계 확인 가능 | 원본 테이블 수정 시 추가적인 오버헤드 발생 |

<br>

### 4. 통계 테이블 구조 설계 핵심

통계 테이블의 정석 구조.

* **차원(Dimension)**: 통계를 나누는 기준 (예: 날짜, 상품ID, 지역코드, 결제수단).
* **측정값(Measure)**: 실제 집계된 수치 (예: 주문건수, 총결제금액, 평균할인율).
* **구조 예시**: `[집계일자(PK), 상품ID(PK), 총판매수량, 총판매금액, 등록일시]`

<br>

### 5. 시나리오별 사용 예시 (Scenario & Example)

* **일별 매출 통계 테이블 설계**: "쇼핑몰 매출 리포트 최적화"
```sql
-- 매일 새벽 배치를 통해 전날의 데이터를 집계하여 저장
CREATE TABLE stat_daily_sales (
    sale_date DATE NOT NULL,          -- 차원: 날짜
    category_id INT NOT NULL,         -- 차원: 카테고리
    total_order_count INT DEFAULT 0,  -- 측정값: 주문 건수
    total_sales_amount BIGINT DEFAULT 0, -- 측정값: 총 매출액
    updated_at DATETIME,
    PRIMARY KEY (sale_date, category_id)
);

```
<br>

* **반정규화를 통한 조회 성능 극대화**: "조인 없이 통계 데이터 바로 출력"
```sql
-- 상품명을 매번 상품 테이블에서 조인하지 않도록 통계 테이블에 포함
CREATE TABLE stat_product_rank (
    rank_date DATE NOT NULL,
    product_id BIGINT NOT NULL,
    product_name VARCHAR(100), -- 반정규화: 조회 시 조인 제거용
    sales_rank INT,
    PRIMARY KEY (rank_date, product_id)
);

```
<br>

* **누적 통계와 증분 업데이트**: "실시간 포인트 집계"
```sql
-- 원본 로그가 쌓일 때마다 통계 테이블의 수치를 업데이트(Increment)
-- INSERT INTO ... ON DUPLICATE KEY UPDATE 활용
INSERT INTO stat_user_point (user_id, total_point)
VALUES (1001, 500)
ON DUPLICATE KEY UPDATE total_point = total_point + 500;

```
<br>

* **Re-Batch(재집계) 시나리오**: "데이터 정합성 오류 시 복구"
```sql
-- 특정 날짜의 통계 데이터에 오류가 발견된 경우
-- 1. 해당 날짜 통계 삭제
DELETE FROM stat_daily_sales WHERE sale_date = '2025-05-01';
-- 2. 원천 데이터(orders)로부터 다시 집계하여 INSERT
INSERT INTO stat_daily_sales (sale_date, category_id, ...)
SELECT order_date, category_id, COUNT(*), SUM(price)
FROM orders WHERE order_date = '2025-05-01' GROUP BY category_id;

```

<br>

### 6. 실무 포인트

* **"원천 데이터가 진리다"**: 통계 테이블은 언제든 원천 데이터를 통해 다시 만들 수 있어야함. 통계 값이 이상하다면 원천 데이터를 다시 집계(Re-Batch)하여 정정할 수 있도록 설계해야함.

* **조인 최소화**: 통계 테이블은 성능을 위해 존재함. 조회 시 다른 테이블과 조인하지 않도록 필요한 속성(예: 상품명, 카테고리명)을 **반정규화**해서 통계 테이블에 직접 들고 있는 것이 유리함.
* **인덱스 전략**: 통계 테이블은 `집계일자 + 차원값` 순서로 복합 인덱스를 구성하는 경우가 많음. 어떤 조건으로 조회가 많이 일어나는지 파악하여 인덱스를 설계해야함.
* **대용량 처리**: 통계 테이블 자체도 커질 수 있음. 오래된 통계 데이터는 파티셔닝을 통해 분리하거나 별도의 데이터 웨어하우스(DW)로 이관하는 것을 고려해야함.