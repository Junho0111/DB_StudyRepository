# 데이터베이스 설계 (논리적 모델링 - 1:1 및 N:M)

### 1. 일대일(1:1) 관계의 매핑

일대일 관계는 어느 쪽이든 외래 키(FK)를 가질 수 있으며, 아래에 비즈니스 상황에 따른 선택 기준을 제시함.

| 방식 | 설명 | 특징 |
| --- | --- | --- |
| **주 테이블에 외래 키** | 주된 엔티티(예: 회원)가 상세 정보(예: 프로필)의 FK를 가짐 | 주 테이블 조회 시 연관 데이터 확인이 쉬워 객체지향 개발자가 선호함. |
| **대상 테이블에 외래 키** | 상세 정보 테이블이 주 테이블의 FK를 가짐 | 관계를 1:1에서 1:N으로 확장하기 유리하여 DB 설계자가 선호함. |

* **제약 조건**: 1:1을 유지하기 위해 외래 키 컬럼에 반드시 **UNIQUE** 제약 조건을 걸어줘야함.

<br>

### 2. 다대다(N:M) 관계의 문제점

관계형 데이터베이스는 두 테이블 사이에 직접적인 다대다 관계를 구현할 수 없음.

* **이유**: 한 컬럼에 여러 개의 값을 넣을 수 없으며(원자성 위배), 조인 시 데이터가 기하급수적으로 불어나는 '카테시안 곱' 문제가 발생하기 때문임.

<br>

### 3. 다대다 관계의 해결: 연결 테이블 (Mapping Table)

가장 강조하는 핵심 해결책. 다대다 관계를 **두 개의 일대다(1:N) 관계**로 풀어내는 것.

* **방법**: 두 엔티티 사이에 새로운 **'연결 테이블'**을 생성.
* **구성**: 연결 테이블은 양쪽 부모 테이블의 기본 키(PK)를 외래 키(FK)로 가져와서 자신의 PK(보통 복합키 또는 새로운 대리키)로 사용함.

**[예시: 학생 ↔ 과목]**

1. 학생(1) ↔ 수강신청(N)
2. 과목(1) ↔ 수강신청(N)

* '수강신청' 테이블이 연결 테이블 역할을 수행하며, 누가 어떤 과목을 듣는지 기록함.

<br>

### 4. 연결 테이블의 확장

연결 테이블은 단순히 두 테이블을 연결하는 것에 그치지 않고, **추가적인 정보**를 담는 엔티티로 발전할 수 있음.

* **예시**: '수강신청' 테이블에 '신청일자', '성적', '결제상태' 등의 속성을 추가하여 관리할 수 있음. 이를 통해 단순한 관계가 하나의 중요한 비즈니스 데이터(엔티티)가됨.

<br>

### 5. 시나리오별 사용 예시 (Scenario & Example)

* **1:1 관계 구현**: "회원과 마이페이지 설정 정보"
```sql
-- 주 테이블인 member에 FK를 두어 접근성을 높인 케이스
CREATE TABLE member (
    member_id BIGINT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    settings_id BIGINT UNIQUE, -- 1:1 보장을 위한 UNIQUE 제약
    CONSTRAINT fk_member_settings FOREIGN KEY (settings_id) REFERENCES member_settings(id)
);

CREATE TABLE member_settings (
    id BIGINT PRIMARY KEY,
    theme_color VARCHAR(10),
    use_alarm CHAR(1)
);

```
<br>

* **N:M 관계의 해소 (연결 테이블)**: "상품과 카테고리 사이의 매핑"
```sql
-- 상품(N) : 카테고리(M) 관계를 상품_카테고리 연결 테이블로 풀어냄
CREATE TABLE product_category (
    product_id BIGINT,
    category_id BIGINT,
    PRIMARY KEY (product_id, category_id), -- 복합키로 유일성 보장
    CONSTRAINT fk_pc_product FOREIGN KEY (product_id) REFERENCES product(id),
    CONSTRAINT fk_pc_category FOREIGN KEY (category_id) REFERENCES category(id)
);

```
<br>

* **연결 테이블의 속성 확장**: "단순 연결을 넘어선 주문_상품 데이터"
```sql
-- 주문과 상품의 연결 테이블에 '주문수량'과 '주문금액'이라는 추가 정보를 담음
CREATE TABLE order_item (
    order_item_id BIGINT AUTO_INCREMENT PRIMARY KEY, -- 대리키 권장
    order_id BIGINT,
    product_id BIGINT,
    order_price INT, -- 주문 시점의 가격
    count INT,       -- 주문 수량
    CONSTRAINT fk_oi_order FOREIGN KEY (order_id) REFERENCES orders(id),
    CONSTRAINT fk_oi_product FOREIGN KEY (product_id) REFERENCES product(id)
);

```
<br>

* **1:1 관계의 확장성 고려**: "나중에 1:N으로 변할 가능성이 있는 관계"
```sql
-- 현재는 한 명의 직원이 하나의 법인카드(1:1)만 쓰지만, 
-- 향후 여러 카드를 가질 수 있다면 카드 테이블에 직원_id(FK)를 두는 것이 유연함
CREATE TABLE corporate_card (
    card_id BIGINT PRIMARY KEY,
    card_number VARCHAR(20),
    employee_id BIGINT -- UNIQUE를 빼면 즉시 1:N으로 확장 가능
);

```
<br>

### 6. 요약 & 실무 포인트

* **다대다는 무조건 풀어라**: 설계 단계에서 N:M이 보인다면 기계적으로 연결 테이블을 떠올려야함.
* **연결 테이블의 PK 전략**: 두 부모의 FK를 묶어서 복합 PK로 쓸 수도 있지만, 유지보수와 확장성을 위해 **새로운 대리 키(id)**를 PK로 두는 것을 더 권장함.
* **1:1 관계의 신중함**: 사실 많은 1:1 관계는 하나의 테이블로 합칠 수 있는 경우가 많음. 테이블 분리가 정말 보안이나 성능(컬럼 분산) 측면에서 필요한지 검토해야함.