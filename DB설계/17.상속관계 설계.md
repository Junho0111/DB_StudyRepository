# 상속 관계 설계 (Inheritance Mapping)

### 1. 관계형 DB와 상속 관계

관계형 데이터베이스에는 객체지향의 '상속' 개념이 없으며, 대신 **슈퍼타입-서브타입 관계(Supertype-Subtype Relationship)**라는 모델링 기법을 사용하여 상속을 구현함.

* **슈퍼타입**: 공통 부분 (예: 상품)
* **서브타입**: 상세 부분 (예: 음반, 영화, 책)

<br>

### 2. 주요 설계 전략 (3가지)

#### ① 조인 전략 (Joined Strategy)

각 엔티티를 모두 테이블로 만들고, 자식이 부모의 PK를 받아 PK 겸 FK로 사용하는 방식임. 가장 **정규화된 방식**임.

* **구조**: 부모 테이블 + 자식 테이블 (조회 시 JOIN 사용)
* **장점**: 설계가 깔끔하고 저장 공간이 효율적임. (무결성 높음)
* **단점**: 조회 시 조인이 많이 발생하여 성능이 저하될 수 있고, 데이터 삽입 시 쿼리가 두 번 실행됨.

#### ② 단일 테이블 전략 (Single Table Strategy)

서비스 규모가 크지 않거나 구조가 단순할 때 사용함. 모든 속성을 하나의 테이블에 다 몰아넣는 방식임.

* **구조**: 하나의 테이블에 모든 컬럼 배치 + 구분 컬럼(`DTYPE`) 추가
* **장점**: 조인이 필요 없어 조회 성능이 매우 빠르고 쿼리가 단순함.
* **단점**: 자식 엔티티가 사용하는 컬럼 외에는 모두 **NULL을 허용**해야 하며, 테이블이 너무 커질 수 있음.

#### ③ 구현 클래스마다 테이블 전략 (Table-per-Class Strategy)

부모 테이블 없이 자식 테이블들만 각각 만드는 방식임. **실무에서 추천하지 않음.**

* **구조**: 부모의 속성을 자식 테이블들이 각각 중복해서 가짐
* **장점**: 특정 자식 타입을 조회할 때 속도가 빠름.
* **단점**: 여러 자식 타입을 묶어서 조회할 때(예: 전체 상품 조회) `UNION`을 써야 하므로 성능이 매우 나쁨.

<br>

### 3. 전략 선택의 기준

실무 선택 가이드.

1. **기본은 조인 전략**: 비즈니스가 복잡하고 정규화가 중요하다면 조인 전략을 우선 고려해야함.
2. **단순할 땐 단일 테이블**: 확장이 거의 없고 조회가 압도적으로 많다면 단일 테이블 전략이 유리함.
3. **중간은 없다**: 구현 클래스마다 테이블 전략은 데이터 일관성 관리가 어려워 지양함.

<br>

### 4. 핵심 속성: 구분 컬럼 (Discriminator)

상속 설계 시 슈퍼타입 테이블(또는 단일 테이블)에는 이 행이 어떤 서브타입인지를 나타내는 컬럼이 반드시 필요함.

* 예: `DTYPE` (값: `ALBUM`, `MOVIE`, `BOOK`)

<br>

### 5. 시나리오별 사용 예시 (Scenario & Example)

* **조인 전략 (Joined Strategy) 구현**: "상품-음반/영화/도서 계층 설계"
```sql
-- [슈퍼타입] 공통 속성 정의
CREATE TABLE item (
    item_id BIGINT PRIMARY KEY,
    name VARCHAR(100),
    price INT,
    dtype VARCHAR(10) -- 구분 컬럼 (ALBUM, MOVIE, BOOK)
);

-- [서브타입] 상세 속성만 보유, PK는 부모의 PK를 공유(식별 관계)
CREATE TABLE album (
    item_id BIGINT PRIMARY KEY,
    artist VARCHAR(50),
    FOREIGN KEY (item_id) REFERENCES item(item_id)
);

```
<br>

* **단일 테이블 전략 (Single Table Strategy)**: "성능 최적화가 최우선인 경우"
```sql
-- 모든 서브타입의 컬럼을 하나로 통합, 조인 없이 즉시 조회 가능
CREATE TABLE item (
    item_id BIGINT PRIMARY KEY,
    name VARCHAR(100),
    price INT,
    artist VARCHAR(50), -- Album 전용 (Null 허용)
    director VARCHAR(50), -- Movie 전용 (Null 허용)
    author VARCHAR(50), -- Book 전용 (Null 허용)
    dtype VARCHAR(10) NOT NULL
);

```
<br>

* **구분 컬럼(Discriminator)의 실제 활용**: "다형성 쿼리 처리"
```sql
-- 전체 상품 중 '영화' 타입만 조회하고 싶을 때 DTYPE 필터링 활용
SELECT i.*, m.director 
FROM item i
JOIN movie m ON i.item_id = m.item_id
WHERE i.dtype = 'MOVIE';

```
<br>

* **참조 무결성 유지**: "서브타입 데이터 삭제 시 연쇄 반응"
```sql
-- 조인 전략에서 부모(item)가 삭제될 때 자식(album)도 삭제되도록 설정
ALTER TABLE album 
ADD CONSTRAINT fk_album_item 
FOREIGN KEY (item_id) REFERENCES item(item_id) 
ON DELETE CASCADE;

```

<br>

### 6. 실무 포인트

* **객체와 DB의 차이**: 객체는 상속이 자연스럽지만, DB는 조인 비용이 발생함. JPA를 사용한다면 `@Inheritance` 어노테이션으로 이 전략들을 아주 쉽게 바꿀 수 있음.
* **정규화의 가치**: 단일 테이블 전략은 편하지만, 나중에 데이터가 수천만 건이 쌓이고 서브타입이 늘어나면 테이블 관리가 불가능해짐. 장기적인 서비스라면 **조인 전략**이 안전함.

* **공통 필드 활용**: 등록일, 수정일 같은 공통 필드는 슈퍼타입에 두어 일관되게 관리하여야함.