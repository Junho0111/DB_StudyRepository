# 계층 구조 설계 (Hierarchical Data Design)

### 1. 계층 구조란?

데이터 간에 **부모-자식 관계**가 형성되어 트리(Tree) 형태를 띠는 구조.

* **실무 예시**: 카테고리(대분류 > 중분류 > 소분류), 답변형 게시판(원글 > 답글 > 재답글), 조직도(본부 > 팀 > 개인).

<br>

### 2. 주요 설계 방식 1: 셀프 참조 (Self-Referencing)

가장 기본적이고 직관적인 방식으로, 동일한 테이블 내에서 자신의 PK를 부모 ID(FK)로 참조함.

* **테이블 구조**: `ID(PK)`, `NAME`, `PARENT_ID(FK)`
* **장점**: 구조가 단순하고 계층의 깊이(Depth)에 제한이 없음.
* **단점**: 특정 노드의 모든 하위 자식을 조회할 때 재귀 쿼리(Recursive Query)가 필요하여 쿼리가 복잡해지고 성능이 저하될 수 있음.

<br>

### 3. 주요 설계 방식 2: 경로 열거 (Path Enumeration)

각 노드에 루트부터 자신까지의 전체 경로를 문자열로 저장하는 방식.

* **구조**: `ID`, `NAME`, `PATH` (예: `1/3/10/15`)
* **장점**: `LIKE '1/3/%'`와 같은 쿼리로 특정 노드의 모든 후손을 한 번에 조회할 수 있어 성능상 유리함.
* **단점**: 경로 문자열의 길이에 제한이 생길 수 있고, 중간 노드가 이동할 경우 하위 모든 경로를 업데이트해야 하는 비용이 발생함.

<br>

### 4. 주요 설계 방식 3: 계층별 컬럼 나열 (Flat Table)

레벨이 고정되어 있을 때 사용하는 방식.

* **구조**: `대분류_ID`, `중분류_ID`, `소분류_ID`를 한 행에 모두 기록.
* **장점**: 조인이 필요 없어 조회 성능이 가장 빠름.
* **단점**: 계층의 깊이가 가변적인 경우 대응이 불가능하며 확장이 어려움.

<br>

### 5. 시나리오별 사용 예시 (Scenario & Example)

* **셀프 참조(Self-Referencing) 구현**: "조직도 및 무제한 카테고리 설계"
```sql
-- 테이블 하나에서 부모의 ID를 참조하여 계층을 형성함
CREATE TABLE category (
    category_id BIGINT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    parent_id BIGINT, -- 부모 카테고리 참조 (FK)
    sort_order INT DEFAULT 1,
    CONSTRAINT fk_category_parent FOREIGN KEY (parent_id) REFERENCES category(category_id)
);

-- [데이터 예시] 1(가전) -> 2(냉장고) -> 3(비스포크)
INSERT INTO category VALUES (1, '가전', NULL, 1);
INSERT INTO category VALUES (2, '냉장고', 1, 1);
INSERT INTO category VALUES (3, '비스포크', 2, 1);

```
<br>

* **경로 열거(Path Enumeration) 조회**: "특정 분류의 하위 상품 전체 검색"
```sql
-- PATH 컬럼에 상위 경로를 문자열로 보관함 (예: '1/', '1/2/', '1/2/3/')
-- '가전(ID:1)' 하위의 모든 상품을 조회할 때 인덱스 활용 가능
SELECT * FROM product 
WHERE category_path LIKE '1/%';

```
<br>

* **재귀 쿼리(Recursive Query) 활용**: "상위 부모부터 최하위 자식까지 한 번에 가져오기"
```sql
-- MySQL 8.0 이상 WITH RECURSIVE 문법 예시
WITH RECURSIVE category_tree AS (
    SELECT category_id, name, parent_id, 1 AS depth
    FROM category WHERE parent_id IS NULL -- Root 노드 선택
    UNION ALL
    SELECT c.category_id, c.name, c.parent_id, ct.depth + 1
    FROM category c
    INNER JOIN category_tree ct ON c.parent_id = ct.category_id -- 자식 노드 결합
)
SELECT * FROM category_tree ORDER BY depth, sort_order;

```
<br>

* **계층 이동 처리**: "특정 부서를 다른 본부 하위로 변경"
```sql
-- 셀프 참조 구조에서는 parent_id 하나만 바꾸면 하위 전체가 자동으로 이동됨 (유지보수 유리)
UPDATE department SET parent_id = 20 WHERE dept_id = 105;

```

<br>

### 6. 실무 포인트

* **재귀 쿼리의 활용**: 최신 DBMS(Oracle, PostgreSQL, MySQL 8.0+)에서는 `WITH RECURSIVE` 문법을 지원하므로, 셀프 참조 구조에서도 성능 문제를 상당 부분 해결할 수 있음.
* **순서 보장(Sort Order)**: 같은 부모를 가진 형제 노드들 사이의 출력 순서를 결정하는 `sort_order` 컬럼을 반드시 추가해야함.
* **깊이(Depth) 제한**: 무제한 계층이 필요한지, 아니면 3단계 정도로 제한해도 되는지 비즈니스 요구사항을 먼저 확정해야하고, 단계가 고정되어 있다면 설계를 훨씬 단순화할 수 있음.
* **정규화 vs 성능**: 계층 구조가 너무 깊고 조회 트래픽이 많다면, 정규화를 조금 포기하더라도 '경로 열거' 방식을 섞어서 사용하는 트레이드오프가 필요.