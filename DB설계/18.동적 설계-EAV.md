# 동적 설계 - EAV (Entity-Attribute-Value)

### 1. EAV 모델이란?

데이터의 구조가 고정되어 있지 않고, **속성(Attribute)** 자체가 데이터의 **값(Value)**처럼 저장되는 유연한 설계 방식. '오픈 스키마' 또는 '수직형 테이블' 구조라고도 불림.

* **Entity**: 대상 객체 (예: 상품, 사용자)
* **Attribute**: 속성 이름 (예: 색상, 사이즈, 무게)
* **Value**: 실제 값 (예: 빨강, XL, 5kg)

<br>

### 2. EAV 모델의 테이블 구조

일반적인 방식은 하나의 테이블에 컬럼을 계속 추가하지만, EAV는 데이터를 세로로 쌓음.

| Entity_ID | Attribute_Name | Attribute_Value |
| --- | --- | --- |
| 1 (아이폰) | 용량 | 256GB |
| 1 (아이폰) | 색상 | 그래파이트 |
| 2 (티셔츠) | 사이즈 | XL |
| 2 (티셔츠) | 소재 | 면 100% |

<br>

### 3. 언제 사용하는가? (적용 사례)

* **속성이 너무 많은 경우**: 상품군마다 필요한 속성이 수백 개인데, 실제 상품 하나가 사용하는 속성은 몇 개 안 될 때 (Sparse Data).
* **속성이 계속 변하는 경우**: 사용자가 직접 속성을 추가해야 하는 커스텀 설정 기능을 만들 때.
* **비즈니스 가변성**: 의료 기록(환자마다 검사 항목이 다름)이나 이커머스의 복잡한 옵션 체계.

<br>

### 4. EAV 모델의 장점과 치명적인 단점

#### **장점**

* **유연성**: 테이블 스키마 변경(ALTER TABLE) 없이 새로운 속성을 무한히 추가할 수 있음.
* **공간 효율**: 값이 있는 데이터만 저장하므로 NULL 값이 차지하는 공간을 낭비하지 않음.

#### **단점 (주의를 강조하는 이유)**

* **쿼리 복잡성**: 하나의 객체를 조회할 때 여러 행을 읽어야 하므로 `JOIN`이나 `GROUP BY`, `PIVOT` 연산이 매우 복잡짐.
* **데이터 타입 불일치**: 모든 값을 문자열(VARCHAR) 등으로 저장해야 하므로, 숫자나 날짜 데이터의 무결성을 체크하기 어려움. (예: 가격 컬럼에 '문자'가 들어가는 현상)
* **성능 저하**: 인덱스 활용이 어렵고, 데이터 양이 많아지면 조회 속도가 급격히 느려짐.

<br>

### 5. 시나리오별 사용 예시 (Scenario & Example)

* **EAV 구조 설계**: "상품군별로 제각각인 상세 옵션 관리"
```sql
-- 1. 속성 정의 테이블 (Attribute Definition)
CREATE TABLE product_attributes (
    attr_id INT PRIMARY KEY,
    attr_name VARCHAR(50) -- '용량', '소재', '배터리시간' 등
);

-- 2. 실제 값 저장 테이블 (EAV 핵심)
CREATE TABLE product_values (
    product_id BIGINT,
    attr_id INT,
    attr_value TEXT, -- 모든 타입을 담기 위해 주로 TEXT나 VARCHAR 사용
    PRIMARY KEY (product_id, attr_id),
    FOREIGN KEY (attr_id) REFERENCES product_attributes(attr_id)
);

```
<br>

* **데이터 조회 시의 복잡성**: "아이폰의 용량과 색상을 동시에 조회하기"
```sql
-- 일반 테이블이면 SELECT 용량, 색상 FROM ... 이면 끝날 쿼리가
-- EAV에서는 속성 수만큼 SELF JOIN 하거나 피벗 연산이 필요함
SELECT 
    p.product_name,
    MAX(CASE WHEN a.attr_name = '용량' THEN v.attr_value END) AS capacity,
    MAX(CASE WHEN a.attr_name = '색상' THEN v.attr_value END) AS color
FROM product p
JOIN product_values v ON p.product_id = v.product_id
JOIN product_attributes a ON v.attr_id = a.attr_id
GROUP BY p.product_id;

```
<br>

* **하이브리드(Hybrid) 전략**: "공통 속성과 가변 속성의 분리"
```sql
-- 검색과 정렬이 자주 일어나는 핵심 정보는 일반 컬럼(Static)으로,
-- 상품마다 다른 부가 정보는 JSON(Dynamic)으로 관리
CREATE TABLE product (
    product_id BIGINT PRIMARY KEY,
    name VARCHAR(100) NOT NULL, -- 공통
    price INT NOT NULL,         -- 공통 (인덱스 필요)
    additional_info JSON        -- 가변 속성 (색상, 무게, 제조국 등)
);

```
<br>

* **데이터 타입 무결성 문제**: "숫자 계산이 필요한 경우의 위험성"
```sql
-- EAV의 attr_value가 문자열일 경우, '1000' + '2000'을 하려면 
-- 매번 CAST(attr_value AS UNSIGNED) 처리를 해야 하며, 
-- 실수로 'ABC'가 저장되면 쿼리 실행 중 에러가 발생함.

```

<br>

### 6. 실무 포인트

* **"가급적 피하라"**: EAV는 최후의 수단임. 일반적인 정규화나 '상속 관계 설계'로 해결할 수 있다면 그쪽이 훨씬 나음.
* **절충안 (JSON 활용)**: 최근에는 MySQL이나 PostgreSQL에서 제공하는 **JSON 타입** 컬럼을 사용하는 것이 성능과 유연성 측면에서 EAV보다 훨씬 효율적임.

* **하이브리드 전략**: 핵심적인 공통 속성(이름, 가격)은 일반 컬럼으로 만들고, 가변적인 부가 정보만 EAV나 JSON으로 관리하는 것이 실무적인 정석임.
