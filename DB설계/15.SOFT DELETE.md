김영한 강사님의 **실전 데이터베이스 설계 2편 - 섹션 6. Soft Delete (논리 삭제)** 내용을 강의 자료를 기반으로 정리해 드립니다. 실무에서 데이터를 실제로 삭제하지 않고 삭제된 것처럼 관리하는 매우 중요한 기법입니다.

---

# 5. Soft Delete (논리 삭제)

### 1. Soft Delete vs Hard Delete

데이터를 삭제하는 방식은 크게 두 가지로 나뉩니다.

| 구분 | Hard Delete (물리 삭제) | Soft Delete (논리 삭제) |
| --- | --- | --- |
| **방법** | `DELETE` 쿼리로 데이터 완전 삭제 | `UPDATE` 쿼리로 삭제 상태만 변경 |
| **특징** | 저장 공간 절약, 구현 단순 | **데이터 복구 가능**, 이력 보존 |
| **실무 활용** | 개인정보 파기 등 법적 의무 시 | 주문, 게시글 등 비즈니스 데이터 |

### 2. 주요 설계 방식

Soft Delete를 구현하기 위해 테이블에 상태를 나타내는 컬럼을 추가합니다.

* **방식 1: 삭제 여부(Y/N)**
* 컬럼: `is_deleted` (Boolean/Char)
* 설명: 삭제되면 'Y', 정상은 'N'.


* **방식 2: 삭제 일시 (권장)**
* 컬럼: `deleted_at` (Datetime)
* 설명: 삭제된 시간을 기록. 값이 `NULL`이면 미삭제, 값이 있으면 삭제된 데이터로 간주.
* **장점**: 삭제 여부뿐만 아니라 **"언제 삭제되었는지"**까지 알 수 있어 활용도가 훨씬 높습니다.



### 3. Soft Delete의 영향 (주의사항)

논리 삭제를 도입하면 모든 쿼리에서 데이터 노출 범위를 신경 써야 합니다.

1. **조회(SELECT) 시 필터링**: 모든 조회 쿼리에 `WHERE deleted_at IS NULL` 조건이 붙어야 합니다. (실수하면 삭제된 데이터가 노출되는 대형 사고 발생)
2. **UNIQUE 제약 조건 충돌**:
* 아이디가 `user1`인 회원이 탈퇴(Soft Delete)한 후, 새로운 회원이 `user1`으로 가입하려 할 때 문제가 생깁니다.
* **해결**: UNIQUE 인덱스에 `deleted_at`을 포함하거나, 삭제 시 식별값을 변경(예: `user1_deleted_20231001`)하는 처리가 필요합니다.



### 4. 참조 무결성과 Soft Delete

외래 키(FK) 관계에 있는 부모-자식 테이블에서 삭제 처리가 까다로워집니다.

* 부모(게시글)가 Soft Delete 되면 자식(댓글)들도 조회되지 않도록 **애플리케이션 단에서 연쇄 처리**를 하거나, 자식들도 일괄 Soft Delete 상태로 바꿔야 합니다.
* DB의 `ON DELETE CASCADE`는 물리 삭제용이므로 Soft Delete에서는 직접 로직을 짜야 합니다.

### 5. 김영한의 '실무 포인트'

* **글로벌 필터(Global Filter)**: JPA(Hibernate)의 `@Where`나 `@SQLDelete` 같은 기능을 활용하면, 개발자가 수동으로 `WHERE` 절을 붙이지 않아도 자동으로 삭제된 데이터를 제외해 줍니다. 실무에서는 이 방식을 강력 권장합니다.
* **인덱스 성능**: 삭제된 데이터가 전체의 90% 이상을 차지한다면, `deleted_at IS NULL` 조건이 인덱스 효율을 떨어뜨릴 수 있습니다. 이 경우 오래된 삭제 데이터는 주기적으로 별도의 백업 테이블로 옮기고 실제 테이블에서는 지우는 전략이 필요합니다.
* **개인정보 보호법**: Soft Delete로 데이터를 남겨두더라도, 법적으로 정해진 보유 기간이 지나면 반드시 **Hard Delete**를 통해 영구 파기해야 한다는 점을 잊지 마세요.

---

**정리가 완료되었습니다.** Soft Delete는 데이터 보존을 위해 필수적이지만 관리가 까다롭습니다. 이어서 **'섹션 7. 타임존(Timezone) 설계'** 혹은 다른 주제가 필요하시면 말씀해 주세요!