# 데이터베이스 설계 (물리적 모델링_실습)

### 1. 논리 모델 → 물리 모델 변환

한글로 된 엔티티와 속성명을 **영문 테이블명과 컬럼명**으로 바꾸고, 각 데이터에 맞는 **타입(Type)**을 지정해보는것.

* **회원(Member) → `member**`
* **상품(Product) → `product**`
* **주문(Order) → `orders**` (SQL 예약어인 경우가 많아 보통 `orders`로 사용)

<br>

### 2. 주요 테이블 물리 설계 

구체적인 스펙.

| 테이블명 | 컬럼명 | 데이터 타입 | 제약 조건 | 비고 |
| --- | --- | --- | --- | --- |
| **member** | `member_id` | `BIGINT` | `PK`, `AUTO_INCREMENT` | 대리 키 권장 |
|  | `login_id` | `VARCHAR(20)` | `NOT NULL`, `UNIQUE` | 로그인용 아이디 |
|  | `name` | `VARCHAR(50)` | `NOT NULL` |  |
| **product** | `product_id` | `BIGINT` | `PK`, `AUTO_INCREMENT` |  |
|  | `name` | `VARCHAR(100)` | `NOT NULL` |  |
|  | `price` | `INT` | `DEFAULT 0` | 가격 |
| **orders** | `order_id` | `BIGINT` | `PK`, `AUTO_INCREMENT` |  |
|  | `member_id` | `BIGINT` | `FK`, `NOT NULL` | 주문 회원 |
|  | `order_date` | `DATETIME` | `NOT NULL` | 주문 일시 |

<br>

### 3. 외래 키(FK) 및 인덱스 설정 

성능과 무결성을 위해 다음 사항을 적용.

* **FK 설정**: `orders` 테이블의 `member_id`가 `member` 테이블의 `member_id`를 참조하도록 설정.
* **인덱스**: 검색이 잦을 것으로 예상되는 `member.login_id`나 `product.name`에 인덱스를 추가하여 조회 속도를 확보.
* **연결 테이블**: `product_category` 테이블의 경우, 두 개의 FK를 묶어서 복합 PK로 설정하거나 별도의 `id`를 PK로 생성.

<br>

### 4. DDL(Data Definition Language) 작성

실제 DB에 입력할 쿼리문입니다.

```sql
CREATE TABLE member (
    member_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    login_id VARCHAR(20) NOT NULL UNIQUE,
    name VARCHAR(50) NOT NULL
);

CREATE TABLE orders (
    order_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    member_id BIGINT NOT NULL,
    order_date DATETIME NOT NULL,
    FOREIGN KEY (member_id) REFERENCES member(member_id)
);

```

<br>

### 5. 시나리오별 사용 예시 (Scenario & Example)

* **데이터 타입 선정의 실무적 판단**: "비즈니스 규모에 따른 숫자 타입 결정"
```sql
-- [회원 테이블] 전 세계 사용자를 고려하여 BIGINT 선택
-- [상태 코드] 종류가 10개 미만이라면 공간 절약을 위해 TINYINT 사용
CREATE TABLE member (
    member_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    status_code TINYINT DEFAULT 1 -- 1: 활성, 2: 휴면, 3: 탈퇴
);

```
<br>

* **인덱스(Index) 물리 배치**: "검색 성능 최적화를 위한 보조 인덱스 설정"
```sql
-- 상품명으로 검색하거나, 카테고리별로 정렬하는 쿼리가 많을 경우
-- PK 외에 성능이 필요한 컬럼에 비클러스터형 인덱스 추가
CREATE INDEX idx_product_name ON product(name);
CREATE INDEX idx_product_category ON product(category_id);

```
<br>

* **예약어 피하기 및 네이밍 규칙**: "SQL 에러 방지를 위한 테이블 명명"
```sql
-- [나쁜 예시] CREATE TABLE order (...) -> ORDER는 예약어로 에러 발생 위험 높음
-- [좋은 예시] 테이블명은 관례에 따라 복수형(orders) 또는 접두어(tbl_order) 사용
CREATE TABLE orders (
    order_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    ...
);

```
<br>

* **참조 무결성 제약(FK)의 물리적 선언**: "데이터 삭제 시 연쇄 반응 설정"
```sql
-- 회원이 삭제될 때 해당 회원의 주문 데이터를 어떻게 처리할지 명시
-- 실무에서는 데이터를 보존하기 위해 RESTRICT를 쓰거나 상태값만 변경함
ALTER TABLE orders 
ADD CONSTRAINT fk_orders_member 
FOREIGN KEY (member_id) REFERENCES member(member_id)
ON DELETE RESTRICT; -- 회원 삭제 시 주문이 있으면 삭제 불가하게 방어

```
<br>

### 6. 팁

* **Id 타입 선택**: 미래의 데이터 확장을 고려하여 PK(id)는 `INT`보다는 `BIGINT`(8바이트)를 사용하는 것이 실무에서 안전함.
* **예약어 주의**: `ORDER`, `GROUP`, `USER` 등은 SQL 예약어이므로 테이블명으로 사용할 때 `orders`, `users`와 같이 복수형을 쓰거나 백틱(``)을 활용해야함.
* **물리 설계의 유연성**: 설계는 고정된 것이 아니며, 개발 중간에 요구사항이 변하면 다시 논리 모델을 검토하고 물리 모델을 수정하는 반복 과정이 필요함.