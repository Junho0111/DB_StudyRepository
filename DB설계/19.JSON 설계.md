# JSON 설계 (JSON in RDBMS)

### 1. JSON 설계의 등장 배경

과거에는 가변적인 속성을 처리하기 위해 앞서 배운 **EAV 모델**을 사용했으나, 복잡성과 성능 문제로 인해 한계가 있었고, 이를 해결하기 위해 최신 RDBMS(MySQL 5.7+, PostgreSQL 등)는 JSON 타입을 공식적으로 지원하기 시작함.

* **특징**: 스키마가 정해져 있지 않은(Schema-less) 데이터를 컬럼 하나에 통째로 저장함.
* **용도**: 상품의 상세 옵션, 외부 API 응답 데이터 보관, 사용자 설정값 등.

<br>

### 2. EAV vs JSON 설계 비교

| 구분 | EAV 모델 | JSON 설계 |
| --- | --- | --- |
| **저장 방식** | 데이터를 여러 행(Row)으로 수직 저장 | 하나의 컬럼에 JSON 포맷으로 저장 |
| **조회 성능** | 조인이 많이 발생하여 성능 저하 | 단일 행 조회 시 매우 빠름 |
| **가독성** | 사람이 한눈에 파악하기 힘듦 | JSON 구조로 되어 있어 직관적임 |
| **데이터 타입** | 주로 문자열로 저장 (타입 불명확) | JSON 내부적으로 숫자, 배열 등 지원 |

<br>

### 3. JSON 설계의 장점

* **유연성**: 애플리케이션 요구사항이 변해도 DB 스키마 변경(DDL) 없이 데이터 구조를 바꿀 수 있음.
* **개발 생산성**: 객체 구조를 그대로 저장하고 꺼낼 수 있어 매핑 로직이 단순해짐.
* **인덱스 지원**: 최신 DB는 JSON 내부의 특정 키(Key)에 대해서도 인덱스를 생성할 수 있어 검색 성능이 우수함.

<br>

### 4. 실무 적용 시 주의사항 (단점)

**"RDBMS에서 JSON을 남용하면 안 되는 이유"**

1. **데이터 무결성**: JSON 내부에 필수 값이 빠져있거나 잘못된 타입이 들어와도 DB 차원에서 막기가 어려움.
2. **통계 및 집계의 어려움**: JSON 내부 데이터를 `SUM`, `AVG` 등으로 집계하는 쿼리는 일반 컬럼보다 훨씬 무겁고 복잡함.
3. **수정의 비용**: JSON 내부의 아주 작은 값 하나를 바꿀 때도 문법이 까다롭고 실수할 위험이 있음.

<br>

### 5. 시나리오별 사용 예시 (Scenario & Example)

* **JSON 컬럼 정의 및 저장**: "다양한 규격이 존재하는 전자기기 사양 저장"
```sql
-- MySQL 기준 JSON 컬럼 생성
CREATE TABLE product (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    price INT NOT NULL,
    attributes JSON -- 가변적인 상세 사양 (배터리, 화면크기, CPU 등)
);

-- 데이터 삽입 (JSON 포맷 그대로 저장)
INSERT INTO product (name, price, attributes)
VALUES ('아이폰 15', 1250000, '{"cpu": "A17", "color": ["Black", "Blue"], "storage": "256GB"}');

```
<br>

* **JSON 내부 값 추출 및 조건 검색**: "특정 CPU를 가진 상품 조회"
```sql
-- JSON_EXTRACT나 ->> 연산자를 사용하여 내부 데이터 필터링
-- CPU가 'A17'인 상품만 검색
SELECT name, attributes->>"$.cpu" AS cpu_model
FROM product
WHERE attributes->>"$.cpu" = 'A16';

```
<br>

* **가상 컬럼(Generated Column)을 이용한 인덱싱**: "JSON 검색 성능 최적화"
```sql
-- JSON 내부의 특정 키(Key)를 물리적 컬럼처럼 뽑아내어 인덱스 부여
-- 이 작업을 거치면 JSON 내부 검색도 일반 컬럼만큼 빨라짐
ALTER TABLE product 
ADD COLUMN cpu_type VARCHAR(20) AS (attributes->>"$.cpu") VIRTUAL;

CREATE INDEX idx_cpu_type ON product(cpu_type);

```
<br>

* **하이브리드 전략의 실제**: "주문 정보와 배송 정보"
```sql
-- [일반 컬럼] 주문번호, 결제금액, 주문상태 (검색, 정렬, 통계 필수)
-- [JSON 컬럼] 배송 메시지, 선물 메시지, 커스텀 포장 옵션 (단순 노출용)
CREATE TABLE orders (
    order_id BIGINT PRIMARY KEY,
    total_price INT,
    order_status VARCHAR(20),
    extra_options JSON -- {"gift_wrap": true, "message": "생일 축하해!"}
);

```

<br>

### 5. 실무 포인트 (하이브리드 전략)

* **"핵심은 일반 컬럼, 부가 정보는 JSON"**:
* 이름, 가격, 카테고리 등 **검색과 통계에 자주 쓰이는 데이터**는 반드시 일반 컬럼으로 정규화하여 설계함.
* 상품의 세부 특징, 제조사 커스텀 정보 등 **단순히 화면에 보여주기만 하는 가변 데이터**에 한해서만 JSON을 사용.


* **JSON Path 활용**: SQL에서 JSON 내부 값을 추출할 때 사용하는 문법(`$ .key`)을 익혀두면 효율적인 조회가 가능.
* **결론**: JSON은 관계형 데이터베이스의 강력한 제약 조건을 포기하는 행위임. 편리함에 취해 모든 것을 JSON으로 넣는 순간, RDBMS의 장점을 잃게 된다는 점을 명심해야함.