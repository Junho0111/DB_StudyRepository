# 데이터베이스 설계 (물리적 모델링)

### 1. 물리적 모델링이란?

논리적 모델링에서 정의된 테이블 구조를 바탕으로, 실제 DB 엔진이 데이터를 어떻게 저장하고 관리할지 구체적인 명세(Schema)를 만드는 과정. 이 단계를 **"성능을 위한 최종 튜닝"**이라고 부르기도함.

<br>

### 2. 주요 작업 내용 (핵심 4요소)

| 요소 | 설명 | 포인트 |
| --- | --- | --- |
| **데이터 타입 결정** | 각 컬럼에 가장 적합한 타입 선정 | `VARCHAR(255)` vs `TEXT`, `INT` vs `BIGINT` 등 |
| **인덱스(Index) 설계** | 조회 성능을 위한 인덱스 구성 | PK 자동 인덱스 외에 자주 조회되는 컬럼 추가 |
| **제약 조건 적용** | 무결성을 위한 규칙 적용 | `NOT NULL`, `DEFAULT`, `CHECK` 등 상세 설정 |
| **반정규화 검토** | 성능을 위해 정규화된 구조를 합침 | 조인 비용이 너무 큰 경우에만 제한적 수행 |

<br>

### 3. 데이터 타입 선정 전략

실제 저장 공간과 성능에 직결되므로 신중하게 선택해야함.

* **숫자**: 값의 범위에 따라 `TINYINT`, `INT`, `BIGINT` 등을 선택. (PK는 보통 확장성을 위해 `BIGINT` 권장)
* **문자**: 고정 길이는 `CHAR`, 가변 길이는 `VARCHAR`.
* **날짜**: `DATETIME` 또는 `TIMESTAMP`. (보통 시간대 관리가 용이한 쪽을 추천)

<br>

### 4. 반정규화 (Denormalization)

물리적 모델링 단계에서 성능을 위해 가장 고민하게 되는 부분임.

* **개념**: 정규화로 쪼개진 테이블을 성능 향상을 위해 다시 합치거나 중복 컬럼을 추가하는 작업.
* **기준**: 조회(SELECT) 성능이 서비스 운영에 치명적일 정도로 느릴 때 최후의 수단으로 사용.
* **주의**: 반정규화를 하면 데이터 무결성이 깨질 위험(갱신 이상)이 커지므로, 애플리케이션 단에서 이를 보완하는 로직이 추가되어야함.

<br>

### 5. 시나리오별 사용 예시 (Scenario & Example)

* **데이터 타입 최적화**: "저장 공간 절약과 성능을 고려한 타입 선정"
```sql
-- [비효율] 무분별하게 큰 타입을 사용하면 인덱스 크기가 커지고 메모리 효율이 떨어짐
CREATE TABLE product (
    id BIGINT AUTO_INCREMENT PRIMARY KEY, -- 확장성을 위해 PK는 BIGINT
    is_published CHAR(1),                 -- Y/N 상태값은 고정 길이 CHAR(1)
    description TEXT,                     -- 대용량 텍스트는 VARCHAR보다 TEXT
    price INT UNSIGNED                    -- 가격은 음수가 없으므로 UNSIGNED 적용
);

```
<br>

* **물리적 제약 조건 적용**: "DB 수준에서 데이터 무결성 2차 방어"
```sql
-- [물리 설계] 애플리케이션 로직 외에 DB 제약을 통해 잘못된 데이터 입력을 원천 차단
CREATE TABLE orders (
    order_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    order_date DATETIME DEFAULT CURRENT_TIMESTAMP, -- 값이 없으면 현재 시간 자동 입력
    status VARCHAR(20) NOT NULL,                   -- 빈 값 허용 안 함
    total_price INT CHECK (total_price >= 0)       -- 금액이 음수가 되지 않도록 체크
);

```
<br>

* **전략적 반정규화**: "조인 횟수를 줄여 조회 성능 극대화"
```sql
-- [상황] 주문 목록 조회 시 매번 상품명을 가져오기 위해 조인하는 것이 너무 느림
-- [해결] order_items 테이블에 원래는 없어야 할 product_name을 중복 저장함
CREATE TABLE order_items (
    id BIGINT PRIMARY KEY,
    order_id BIGINT,
    product_id BIGINT,
    product_name VARCHAR(100), -- 반정규화: 조인 없이 상품명을 바로 조회 가능
    price INT
);

```
<br>

* **인덱스(Index) 전략 수립**: "검색 빈도가 높은 컬럼에 물리적 색인 추가"
```sql
-- [조회 패턴] 이메일로 회원을 찾는 기능이 가장 빈번함
-- [물리 설계] email 컬럼에 인덱스를 생성하여 Full Table Scan 방지
CREATE INDEX idx_user_email ON user(email);

```
<br>

### 6. 실무 포인트

* **이름 컨벤션(Naming Convention)**: 실무에서는 `snake_case`를 주로 사용하며, 테이블명은 복수형(`users`)보다는 단수형(`user`)을 선호하는 경향이 있으며, 팀 내 규칙을 정하는 것이 매우 중요.
* **물리적 성능 고려**: 인덱스는 읽기 속도를 높이지만 쓰기(Insert/Update) 속도를 늦춤. 물리 모델링 시점에 데이터의 양과 트래픽을 예상하여 인덱스 개수를 조절해야함.
* **엔진 특성 활용**: MySQL의 경우 `InnoDB` 엔진의 특성(PK 순서대로 저장 등)을 이해하고 설계를 진행해야 성능 손해를 보지 않음.