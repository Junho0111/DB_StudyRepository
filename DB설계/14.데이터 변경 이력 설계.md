# 데이터 변경 이력 설계 (History Data Design)

### 1. 이력 데이터의 개념

데이터베이스에서 값이 변경되었을 때, 이전의 값을 버리지 않고 **시간의 흐름에 따라 기록**해 두는 데이터.

* **필요성**: 장애 복구, 부정 결제 추적, 통계 분석, 고객의 과거 데이터 조회 요구 대응.
* **대상**: 모든 테이블에 적용하기보다는 주문 상태, 상품 가격, 회원 등급 등 비즈니스상 중요한 데이터에 주로 적용.

<br>

### 2. 이력 설계의 기본 원칙

이력을 설계할 때는 다음 두 가지 질문에 답할 수 있어야함.

1. **변경 시점**: 언제 변경되었는가? (`변경일시`)
2. **변경 원인**: 왜 변경되었는가? (`변경사유`, `수정자ID`)

<br>

### 3. 이력 관리 방식 1: 동일 테이블 관리 (이력 추가 방식)

현재 데이터와 과거 데이터를 구분하지 않고 한 테이블에 계속 쌓는 방식.

* **구조**: `ID(PK)`, `내용`, `시작일시`, `종료일시`, `현재여부(Y/N)`
* **장점**: 테이블 구조가 단순하고 현재 데이터와 과거 데이터를 한 번의 쿼리로 조회하기 쉬움.
* **단점**: 데이터량이 급증하면 현재 데이터만 조회할 때도 성능이 저하될 수 있으며, PK를 `ID + 시작일시` 조합으로 잡아야 하는 복잡함이 있음.

<br>

### 4. 이력 관리 방식 2: 이력 테이블 분리 (Log 방식)

현재 상태를 담은 **'마스터 테이블'**과 변경 내역을 담은 **'이력 테이블'**을 완전히 분리하는 방식.

* **구조**:
* **마스터**: `ID(PK)`, `현재값`, `최종수정일`
* **이력**: `이력ID(PK)`, `마스터ID(FK)`, `과거값`, `변경일시`


* **장점**: 마스터 테이블의 크기가 작게 유지되어 일반적인 조회 성능이 매우 우수하고 구조가 명확함.
* **단점**: 현재 값과 과거 이력을 동시에 조회하려면 두 테이블을 Union 하거나 복잡한 Join이 필요함.

<br>

### 5. 시나리오별 사용 예시 (Scenario & Example)

* **이력 테이블 분리 방식 (Log)**: "상품 가격 변동 내역 관리"
```sql
-- [마스터 테이블] 현재 판매가 정보만 유지
CREATE TABLE product (
    product_id BIGINT PRIMARY KEY,
    price INT NOT NULL,
    updated_at DATETIME
);

-- [이력 테이블] 가격이 변할 때마다 스냅샷을 저장
CREATE TABLE product_price_history (
    history_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    product_id BIGINT NOT NULL,
    old_price INT,
    new_price INT,
    change_reason VARCHAR(255),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

```
<br>

* **종료일시(End Date)를 활용한 기간 조회**: "회원 등급 이력 관리"
```sql
-- 특정 시점의 등급을 빠르게 찾기 위해 시작/종료일시를 함께 관리
SELECT grade 
FROM member_grade_history
WHERE member_id = 101
  AND '2025-05-01' BETWEEN start_date AND end_date;

-- 현재 유효한 데이터는 end_date를 '9999-12-31'로 설정
INSERT INTO member_grade_history (member_id, grade, start_date, end_date)
VALUES (101, 'VIP', NOW(), '9999-12-31');

```
<br>

* **변경 사유 및 수정자 기록**: "주문 상태 변경 추적"
```sql
-- 누가, 왜 상태를 변경했는지 반드시 기록하여 CS 대응에 활용
INSERT INTO order_status_history (order_id, status, changer_id, reason, created_at)
VALUES (5001, 'CANCEL', 'admin_01', '고객 단순 변심', NOW());

```
<br>

* **동일 테이블 내 이력 관리 (Y/N 방식)**: "배송지 주소 이력"
```sql
-- 최신 주소 하나만 'Y'로 유지하고 나머지는 'N'으로 관리
SELECT * FROM member_address 
WHERE member_id = 77 AND current_yn = 'Y';

```

<br>

### 6. 실무 포인트

* **스냅샷(Snapshot) vs 변경분(Log)**:
* **스냅샷**: 변경 시점에 전체 로우를 복사하여 저장 (구조는 편하지만 저장 공간 낭비)
* **변경분**: 바뀐 컬럼만 저장 (저장 공간은 아끼지만 조회 로직이 매우 복잡함)
* **결론**: 실무에서는 관리가 편한 **스냅샷 방식**을 주로 사용함.

* **종료일시의 활용**: 이력을 조회할 때 `BETWEEN`을 활용하기 위해 `종료일시` 컬럼을 두는 경우가 많은데, 이때 현재 진행 중인 데이터의 종료일시는 `9999-12-31` 같은 최대값으로 설정하는 관례가 있음.
* **트리거(Trigger) vs 애플리케이션**: 이력을 남기는 로직을 DB 트리거로 짤지, 서비스 코드(Spring 등)에서 짤지 결정해야함. 실무에선 비즈니스 로직의 명확성을 위해 가급적 **애플리케이션 단**에서 처리하는 것을 권장함.

---
<br>
<br>
<br>
<br>

# 데이터 변경 이력 설계 (심화 및 최적화)

### 1. 선분 이력 (Period History) 관리

이력 데이터에서 특정 시점의 데이터를 조회할 때 성능을 극대화하기 위한 설계 방식. 단순히 '변경일' 하나만 두는 것이 아니라, 데이터가 유효한 **시작일시와 종료일시**를 함께 관리함.

* **핵심 구조**: `시작일시`, `종료일시` 컬럼 보유.
* **조회 방식**: `WHERE '2023-10-01' BETWEEN 시작일시 AND 종료일시`
* **장점**: 특정 날짜의 상태를 찾기 위해 복잡한 서브쿼리나 정렬(Order By)을 사용할 필요가 없어 인덱스 효율이 매우 좋음.

<br>

### 2. 현재 데이터 중복 (Current Data Redundancy)

이력 테이블만 운영할 경우, "현재" 상태를 알기 위해 매번 가장 최근의 이력을 조회해야 하는 부담이 있음.

* **최적화 전략**:
1. 마스터 테이블에는 항상 **현재 최신값**만 유지함.
2. 데이터 변경 시, 기존 마스터의 값을 이력 테이블로 옮기고 마스터를 새 값으로 업데이트함.


* **효과**: 전체 트래픽의 대부분인 "현재 상태 조회"를 인덱스 스캔 한 번으로 끝낼 수 있음.

<br>

### 3. 변경 사유 및 유형 세분화

단순히 값만 저장하는 것이 아니라, 어떤 맥락에서 데이터가 변했는지 기록하는 컬럼을 설계함.

* **변경 유형(Action)**: `INSERT`(신규), `UPDATE`(수정), `DELETE`(삭제)
* **변경 채널**: `WEB`(웹사이트), `APP`(앱), `ADMIN`(관리자 페이지), `BATCH`(배치 작업)
* **변경 사유**: "고객 요청", "오기입 수정", "시스템 자동 갱신" 등 비즈니스 사유를 자유 텍스트나 공통 코드로 기록함.

<br>

### 4. 대용량 이력 데이터의 파티셔닝 (Partitioning)

이력 데이터는 시간이 갈수록 무한히 쌓임. 성능 저하를 막기 위해 물리적인 분할이 필요함.

* **범위 파티셔닝(Range Partitioning)**: 주로 `월(Month)` 단위로 테이블을 쪼개서 관리함.
* **장점**:
* 오래된 데이터(예: 3년 전 이력)를 백업하거나 삭제하기 매우 쉬움.
* 특정 기간 조회 시 해당 파티션만 읽으므로 I/O 성능이 향상됨.


<br>

### 5. 시나리오별 사용 예시 (Scenario & Example)

* **선분 이력(Period History) 조회 최적화**: "특정 과거 시점의 상품 가격 찾기"
```sql
-- 2025년 12월 25일 당시의 가격을 조회하는 경우
-- 인덱스(시작일시, 종료일시)가 걸려있다면 매우 빠르게 결과 반환
SELECT price 
FROM product_price_history
WHERE product_id = 101
  AND '2025-12-25 12:00:00' BETWEEN start_at AND end_at;

```
<br>

* **현재 데이터 중복 전략 적용**: "마스터와 이력의 트랜잭션 처리"
```sql
-- [애플리케이션 로직 시나리오]
-- 1. 기존 마스터의 '현재 데이터' 종료일시를 NOW()로 업데이트하여 이력화
UPDATE member_grade_history 
SET end_at = NOW(), current_yn = 'N' 
WHERE member_id = 55 AND current_yn = 'Y';

-- 2. 신규 등급 데이터를 시작일시 NOW(), 종료일시 '9999-12-31'로 삽입
INSERT INTO member_grade_history (member_id, grade, start_at, end_at, current_yn)
VALUES (55, 'VIP', NOW(), '9999-12-31 23:59:59', 'Y');

```
<br>

* **범위 파티셔닝(Range Partitioning) 설계**: "수천만 건의 로그 데이터 물리적 분리"
```sql
-- 월 단위로 파티션을 분리하여 조회 성능 향상 및 오래된 데이터 삭제 용이성 확보
CREATE TABLE access_log (
    log_id BIGINT,
    access_at DATETIME,
    ...
) PARTITION BY RANGE (YEAR(access_at)) (
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p2026 VALUES LESS THAN (2027)
);

```
<br>

* **변경 맥락 기록**: "관리자에 의한 강제 상태 변경 추적"
```sql
-- 단순 값 변경이 아닌 '누가', '어디서', '왜'를 포함한 이력 적재
INSERT INTO account_history (account_id, action_type, channel, reason, manager_id)
VALUES (777, 'LOCK', 'ADMIN_PANEL', '보이스피싱 의심 계좌 동결', 'admin_kim');

```

<br>

### 5. 실무 포인트

* **종료일시의 Default 값**: 현재 유효한 데이터의 종료일시는 `9999-12-31 23:59:59`와 같은 **미래의 최대값**으로 설정하는 것이 관례이며, 그래야 `BETWEEN` 검색 시 현재 데이터가 정상적으로 걸러짐.
* **데이터 정합성 주의**: 마스터 테이블과 이력 테이블을 분리할 경우, 두 테이블의 데이터가 일치하지 않는 문제가 생길 수 있음. 이를 방지하기 위해 **데이터베이스 트랜잭션**을 반드시 하나로 묶어 처리해야함.

* **언제 설계하나?**: 모든 테이블에 이력을 붙이면 개발 공수와 저장 공간이 낭비됨. **"비즈니스 가치가 있는가?"**, **"추후에 증빙이 필요한가?"**를 기준으로 설계 여부를 결정해야함.